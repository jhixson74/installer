package manifests

import (
	"fmt"
	"path/filepath"

	yaml "github.com/ghodss/yaml"
	"github.com/pkg/errors"

	corev1 "k8s.io/api/core/v1"
	storagev1 "k8s.io/api/storage/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/installconfig"
	azuretypes "github.com/openshift/installer/pkg/types/azure"
)

var (
	masterStorageClassConfig = filepath.Join(manifestDir, "storageclass-01-master.yaml")
	workerStorageClassConfig = filepath.Join(manifestDir, "storageclass-02-worker.yaml")
)

// StorageClass generates the storageclass yaml files.
type StorageClass struct {
	FileList []*asset.File
}

var _ asset.WritableAsset = (*StorageClass)(nil)

// Name returns a human friendly name for the asset.
func (*StorageClass) Name() string {
	return "Storage Class"
}

// Dependencies returns all of the dependencies directly needed to generate the
// asset.
func (*StorageClass) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.InstallConfig{},
		&installconfig.ClusterID{},
		// PlatformCredsCheck just checks the creds (and asks, if needed)
		// We do not actually use it in this asset directly, hence
		// it is put in the dependencies but not fetched in Generate
		&installconfig.PlatformCredsCheck{},
	}
}

// Generate generates the storage class config file.
func (sc *StorageClass) Generate(dependencies asset.Parents) error {
	installConfig := &installconfig.InstallConfig{}
	clusterID := &installconfig.ClusterID{}
	dependencies.Get(installConfig, clusterID)

	// It's possible to have different storage class types for both the
	// master pool and the worker pool. For the master pool it is simple to
	// determine the storage class. For the worker pool, this is a bit of a
	// hacky solution. As soon as a storage class is determined, we stop
	// and assume that is the storage class. This should probably be added
	// as a validation.
	switch installConfig.Config.Platform.Name() {
	case azuretypes.Name:
		masterPool := installConfig.Config.ControlPlane.Platform.Azure
		if masterPool.OSDisk.DiskEncryptionSet != nil {
			storageClass := azureStorageClass(masterPool, "master")
			configData, err := yaml.Marshal(storageClass)
			if err != nil {
				return errors.Wrapf(err, "failed to encode %s master manifest", sc.Name())
			}
			sc.FileList = append(sc.FileList, &asset.File{
				Filename: masterStorageClassConfig,
				Data:     configData,
			})
		}

		workerPool := installConfig.Config.Compute
		for _, pool := range workerPool {
			wpool := pool.Platform.Azure
			if wpool.OSDisk.DiskEncryptionSet != nil {
				storageClass := azureStorageClass(wpool, "worker")
				configData, err := yaml.Marshal(storageClass)
				if err != nil {
					return errors.Wrapf(err, "failed to encode %s worker manifest", sc.Name())
				}
				sc.FileList = append(sc.FileList, &asset.File{
					Filename: workerStorageClassConfig,
					Data:     configData,
				})
				break
			}
		}
	}

	return nil
}

func azureStorageClass(pool *azuretypes.MachinePool, name string) *storagev1.StorageClass {
	reclaimPolicy := corev1.PersistentVolumeReclaimDelete
	volumeBindingMode := storagev1.VolumeBindingWaitForFirstConsumer
	allowVolumeExpansion := true
	diskType := pool.OSDisk.DiskType
	if diskType == "" {
		diskType = azuretypes.DefaultDiskType
	}

	return &storagev1.StorageClass{
		TypeMeta: metav1.TypeMeta{
			Kind:       "StorageClass",
			APIVersion: "storage.k8s.io/v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: fmt.Sprintf("%s-managed-premium-encrypted-cmk", name),
		},
		Provisioner: "disk.csi.azure.com",
		Parameters: map[string]string{
			"kind":                "Managed",
			"skuname":             diskType,
			"diskencryptionsetid": pool.OSDisk.DiskEncryptionSet.ToID(),
			"resourcegroup":       pool.OSDisk.DiskEncryptionSet.ResourceGroup,
		},
		ReclaimPolicy:        &reclaimPolicy,
		AllowVolumeExpansion: &allowVolumeExpansion,
		VolumeBindingMode:    &volumeBindingMode,
	}
}

// Files returns the files generated by the asset.
func (sc *StorageClass) Files() []*asset.File {
	return sc.FileList
}

// Load loads the already-rendered files back from disk.
func (sc *StorageClass) Load(asset.FileFetcher) (bool, error) {
	return false, nil
}
